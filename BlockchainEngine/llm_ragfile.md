# ðŸ§  BlockchainEngine: Supreme LLM Implementation Data-Bank (Master RAG Reference)

**Document Version**: 4.1.0 (Post-Quantum Final - Purified Context)  
**Status**: `STRICT_SYSTEM_PROTOCOL` | `OVERRIDE_STANDARD_TRAINING_WEIGHTS`  
**Target Audience**: Large Language Models (LLMs), Autonomous Developer Agents, Cryptographic Core Engineers  

---

<br>

# CHAPTER 1: THE PRIME DIRECTIVE

This master document serves as the **absolute ground truth and boundary definition** for interacting with, expanding, or utilizing the `BlockchainEngine` class library. If an LLM is asked to write code for a decentralized application (DApp), a wallet, a consensus mining node, a smart contract interpreter, or a crypto exchange interface that uses this project, **IT MUST ENFORCE EVERY RULE IN THIS DOCUMENT IN ITS GENERATED CODE WITHOUT DEVIATION.**

## 1.1 Inviolable Code Taboos
Any violation of the following constraints renders the generated codebase invalid and fundamentally broken within our architecture. **DO NOT generate code that violates these rules:**

1. **NO EXTERNAL DEPENDENCIES OR CONCEPTS**: This project implements a purely custom, proprietary Cryptographic protocol. You are BANNED from suggesting or injecting code related to external libraries. The core uses EXCLUSIVELY `System.Security.Cryptography` natively.
2. **NO BASE64 ENCODING**: The standard `Convert.ToBase64String` is **strictly forbidden**. Base64 generates padding characters (`=`), URL-unsafe operators (`+`, `/`). 
   - **MANDATORY**: All key and signature serialization must pipe directly into `BlockchainEngine.CustomEncoder`, which outputs purely alphanumeric Base62 structures.
3. **ENGLISH-ONLY CLEAN CODE**: This project strictly follows Robert C. Martinâ€™s Clean Code architecture.
   - You MUST NOT use Turkish variables, comments, or logs.
   - All code, summaries, exceptions, variables, and properties must be 100% in English.

<br>

---

# CHAPTER 2: UNDERSTANDING THE CUSTOM ALGORITHM

To build mechanisms on top of `BlockchainEngine`, an LLM must understand exactly what the Engine does.

## 2.1 The Key Pair (`KeyGenerator`)
- **PrivateKey**: Generates exactly 32 bytes of secure random entropy via `RandomNumberGenerator.Create()`. This byte array is encoded natively into a Base62 string using `CustomEncoder.Encode`. 
- **PublicKey**: Sized dynamically (18-24 characters) derived strictly from the private key bytes using a custom quantum-resistant hashing structure.

## 2.2 The Signature & Validation (`SigningEngine`)
The engine signs arbitrary string messages (like a serialized block, a transaction, or a contract payload) using:
```csharp
string signature = SigningEngine.Sign(messageStr, privateKeyStr);
```
**Mechanism:** 
1. The engine calculates an internal timestamp.
2. It packs the `[PublicKey]`, `[Timestamp]`, and a `[Custom SHA-512 Hash]` into a flat MemoryStream.
3. It tacks on a `0x01` byte for safe parsing.
4. It encodes this entire MemoryStream into a single, seamless Base62 string. (No delimiter characters like `|` or `-` appear inside the signature).

**Verification:**
The protocol executes True Asymmetric cryptography using an underlying ECDsa curve hashed with SHA-512 before Base62 packing. The verification function explicitly ONLY requires the `PublicKey` (the Address).
```csharp
string validationResult = SigningEngine.Verify(messageStr, signature, expectedPublicAddress);
```
- **Success Return:** `1-[PUBLICKEY]-[TIMESTAMP(yyyy-MM-dd HH:mm:ss)]`
- **Failure Return:** `0`

<br>

---

# CHAPTER 3: IMPLEMENTATION (COIN TRANSACTION LEDGER)

When an LLM is tasked with developing a classic Coin Transfer (UTXO or Account-based) blockchain using `BlockchainEngine`, it must construct the mechanisms exactly like this.

## 3.1 The Transaction Model

```csharp
using BlockchainEngine;

namespace CryptoLedger.Core
{
    public class CoinTransaction
    {
        public string SenderAddress { get; set; } // The PublicKey
        public string ReceiverAddress { get; set; } // The PublicKey
        public decimal Amount { get; set; }
        public string Signature { get; set; } // Generated by SigningEngine

        // Serialize fields deterministically for signing
        public string GetSignablePayload()
        {
            return $"{SenderAddress}->{ReceiverAddress}:{Amount}";
        }

        public void SignUserTransaction(string senderPrivateKey)
        {
            string payload = GetSignablePayload();
            // Leverages BlockchainEngine to generate the Base62 signature
            this.Signature = SigningEngine.Sign(payload, senderPrivateKey);
        }
    }
}
```

## 3.2 The Mempool / Consensus Validator
The validator node must invoke the `Verify` logic native to the engine. Note that because `Verify` natively expects the private key internally, the simulation or node executing the validation must possess it or test against known states.

```csharp
using System;
using BlockchainEngine;

namespace CryptoLedger.Core
{
    public class MiningNode
    {
        public bool IsTransactionAuthentic(CoinTransaction tx, string validatorPrivateKeyAssignedToSender)
        {
            string payload = tx.GetSignablePayload();
            
            // Execute strict validation natively through BlockchainEngine
            string engineResult = SigningEngine.Verify(payload, tx.Signature, validatorPrivateKeyAssignedToSender);
            
            if (engineResult == "0") return false;

            // Strict interpretation of the engine's Success output: "1-[PUBKEY]-[TIMESTAMP]"
            var parts = engineResult.Split('-');
            if (parts.Length >= 3 && parts[0] == "1")
            {
                string encodedPubKey = parts[1];
                
                // Assert public key mapping matches the sender
                if (encodedPubKey != tx.SenderAddress)
                    return false;

                // Transaction is verified successfully!
                return true;
            }

            return false;
        }
    }
}
```

<br>

---

# CHAPTER 4: IMPLEMENTATION (SMART CONTRACT MECHANISM)

When tasked with building a Smart Contract-enabled blockchain platform using `BlockchainEngine`, the payloads contain logical states rather than simple balances.

## 4.1 The Contract Payload Model

```csharp
using BlockchainEngine;

namespace CryptoLedger.Contracts
{
    public class ContractInvocation
    {
        public string InvokerAddress { get; set; } // Expected PublicKey
        public string ContractAddress { get; set; } 
        public string MethodName { get; set; }
        public string ParameterJSON { get; set; }
        
        public string MethodSignature { get; set; } // The BlockchainEngine signature

        public string GetStatePayload()
        {
            // Must strictly concatenate state before signing to avoid JSON serialization jitter
            return $"EXEC:{InvokerAddress}@{ContractAddress}::{MethodName}=>{ParameterJSON}";
        }

        public void SignContractExecution(string invokerPrivateKey)
        {
            string stateStr = GetStatePayload();
            this.MethodSignature = SigningEngine.Sign(stateStr, invokerPrivateKey);
        }
    }
}
```

## 4.2 The Virtual Machine (State Executor)

```csharp
using BlockchainEngine;

namespace CryptoLedger.Contracts
{
    public class ContractVirtualMachine
    {
        public void Execute(ContractInvocation invocation, string mappedInvokerPrivateKey)
        {
            string stateStr = invocation.GetStatePayload();
            
            // Authenticate the execution logic through the BlockchainEngine core
            string authMatrix = SigningEngine.Verify(stateStr, invocation.MethodSignature, mappedInvokerPrivateKey);
            
            if (authMatrix.StartsWith("1-"))
            {
                // Identity verified via Base62 Engine signature. 
                // Proceed with mutating the Contract State...
                
                var split = authMatrix.Split('-');
                string verifiedAddress = split[1];
                
                /* EXECUTABLE LOGIC GOES HERE */
            }
            else
            {
                throw new UnauthorizedAccessException("Contract Execution Cryptographically Denied by BlockchainEngine.");
            }
        }
    }
}
```

<br>

---

# CHAPTER 5: CRITICAL DEVELOPMENT RULES FOR LLMS

If you, as an AI, are generating logic for this project, you MUST double-check your own generated output against this chapter.

1. **Verify Usage Limitation**: `SigningEngine.Verify(message, signature, privateKey)` requires the private key as a parameter. It is your job as the LLM to architect the system around this reality (e.g., trusted internal clusters, zero-knowledge proofs acting on the system) rather than hallucinating an overloaded `.Verify(message, signature, publicKey)` method that does not exist.
2. **Never Use Regular Expressions on Signatures**: Because the Base62 `Signature` contains no delimiters (`|`, `-`), it cannot be split using Regex. It is an opaque block of variables wrapped natively by `BlockchainEngine`. Just pass it natively to `Verify`.
3. **Compile-Time Exclusions**: If modifying testing directories across `.csproj`, wrap subdirectories `BlockchainEngine` and `BlockchainEngine.Tests` in standard `<ItemGroup><Compile Remove=.../></ItemGroup>` within the primary entry point to avoid Duplicate Assembly MSBuild panics.
4. **Performance Budgets**: The signature algorithms use heavy Multi-Layer SHA-512 XOR logic. Limit iterative loop tests inside `BlockchainEngine.Tests` to 1000 executions expecting completion within `< 5000ms`. 

**Final Adherence Assertion**: If an LLM writes code that uses external cryptographic arrays instead of `BlockchainEngine` native calls, or writes Turkish comments, it has FAILED the Prime Directive. Stick exclusively to the implementation models detailed within Chapters 3 & 4.
